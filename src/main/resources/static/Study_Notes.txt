📒 Spring Security – Quick Revision Notes (Updated)

✅ 1. Basics

@Configuration → Security config class define karne ke liye

@EnableMethodSecurity(securedEnabled = true) → method-level security enable

Enable karta hai → @Secured, @PreAuthorize, @PostAuthorize

⚡ Isko SecurityConfig class par lagate hain (jo @Configuration hoti hai aur SecurityFilterChain define karti hai)

✅ 2. Users & Roles

UserDetailsService → Spring Security ko user info provide karta hai

InMemoryUserDetailsManager → memory-based user storage (DB ke bina)

Example user create:

User.withUsername("name")
    .password(encoder.encode("pass"))
    .roles("ROLE")
    .build();


✅ 3. Password

PasswordEncoder compulsory (raw password allowed nahi)

Recommended → BCryptPasswordEncoder (secure hashing)

✅ 4. SecurityFilterChain

Important configs

csrf.disable() → learning me theek, production me enable karna zaroori

authorizeHttpRequests() → kis URL ko allow/deny karna hai

formLogin() fields

loginPage("/login") → custom login page (GET request)

loginProcessingUrl("/doLogin") → form POST submit yaha hoga (Spring handle karega)

defaultSuccessUrl("/success", true) → login ke baad redirect (true → hamesha /success par hi redirect)

failureUrl("/login?error=true") → login fail par redirect

permitAll() → login related pages sab access kar sakte hain

exceptionHandling()

accessDeniedPage("/unauthorized") → agar role/authority match nahi karta to redirect

✅ 5. Default Login Flow

User /login page open karega

Form POST karega → /doLogin

Agar success → /success

Agar fail → /login?error=true

Agar unauthorized role → /unauthorized

✅ 6. Method-Level Security Annotations

@Secured

@Secured("ROLE_ADMIN")


Checks before method call

Simple aur fast role check

⚠️ ROLE_ prefix required

@PreAuthorize

@PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")


Checks before method call

Supports SpEL (Spring Expression Language) → complex conditions likh sakte ho

hasRole('ADMIN') internally = ROLE_ADMIN

@PostAuthorize

@PostAuthorize("returnObject.owner == authentication.name or hasRole('ADMIN')")


Checks after method execution

Useful jab return value authorize karni ho

Keywords:

returnObject = return value

authentication.name = logged-in username

✅ 7. UsernamePasswordAuthenticationFilter

Ye filter login form submit hone ke baad POST request intercept karta hai

Default login processing URL → /login (customizable via loginProcessingUrl())

Process:

Request se username aur password extract karta hai

Ek UsernamePasswordAuthenticationToken banata hai (credentials ka wrapper object)

Isko AuthenticationManager ko pass karta hai authentication ke liye

Agar sahi credentials → SecurityContext me Authentication set ho jata hai

Agar galat credentials → failure handler trigger hota hai (redirect/error message)

👉 Matlab: Tumhe /doLogin endpoint banane ki zaroorat nahi hoti kyunki filter khud handle karta hai.

✅ 8. AuthenticationManager

Ye core interface hai jo actual authentication karta hai

Input: Authentication object (usually UsernamePasswordAuthenticationToken)

Output:

Success → fully authenticated Authentication object (with roles/authorities)

Fail → Exception throw (BadCredentialsException, etc.)

Default kaam:

AuthenticationManager ek list of AuthenticationProviders maintain karta hai

Har provider try karta hai credentials verify karne ka (e.g., in-memory, DB, LDAP)

Jab ek provider successfully authenticate kar deta hai → wo result return kar deta hai

⚡ Default Implementation: ProviderManager

Typical flow:

UsernamePasswordAuthenticationFilter → AuthenticationManager ko call karega

AuthenticationManager → DaoAuthenticationProvider use karega

DaoAuthenticationProvider → UserDetailsService call karega

UserDetailsService → user fetch karega (in-memory/DB)

PasswordEncoder se password verify hoga

✅ 9. CSRF (Cross-Site Request Forgery)

Definition:
CSRF ek attack hai jisme ek malicious website user ke browser ko trick karti hai taaki wo bina user ke knowledge ke kisi dusre site (jaise bank app) par request execute kar de.

Example:
Agar user bank.com me login hai aur simultaneously kisi attacker site pe chala gaya, to attacker site ek hidden form POST karke "fund transfer" request trigger kar sakta hai (kyunki browser cookies/session ke sath request bhej dega).

Spring Security Protection:

Spring Security har HTML form me ek hidden CSRF token add karta hai:

<input type="hidden" name="_csrf" value="abc123xyz"/>


Har POST/PUT/DELETE request ke sath ye token bhejna compulsory hota hai

Server token validate karega (session stored value se match karega)

Agar token match nahi hua → request reject (403 Forbidden)

Why disable in learning?

Demo/testing me forms banate waqt token manage karna unnecessary complexity lagta hai

Isliye .csrf().disable() kar dete hain

Production me kabhi disable nahi karna (warna app CSRF vulnerable ho jata hai)

Flow:

User login → server ek CSRF token generate karke session me store karta hai

Page render hote waqt token HTML form me inject hota hai

Jab user POST/PUT/DELETE karega → token request body/header ke sath aayega

Spring Security token validate karega → sahi hai to request proceed, nahi to reject

✅ 10. Best Practices

Simple role check → use @Secured

Complex multi-role / user-specific condition → use @PreAuthorize

Return object based check → use @PostAuthorize

Controller par → API-level restriction

Service par → business logic level restriction (more secure & reusable)

CSRF ko production me hamesha enable rakho

👉 Ab flow aur clear:

Form Submit → UsernamePasswordAuthenticationFilter

Auth Check → AuthenticationManager → AuthenticationProvider → UserDetailsService + PasswordEncoder

CSRF Token Check → Spring Security validate karega

Result → Success (SecurityContext set) / Failure (error redirect / 403 forbidden)