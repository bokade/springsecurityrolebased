ğŸ“’ Spring Security â€“ Quick Revision Notes (Updated)

âœ… 1. Basics

@Configuration â†’ Security config class define karne ke liye

@EnableMethodSecurity(securedEnabled = true) â†’ method-level security enable

Enable karta hai â†’ @Secured, @PreAuthorize, @PostAuthorize

âš¡ Isko SecurityConfig class par lagate hain (jo @Configuration hoti hai aur SecurityFilterChain define karti hai)

âœ… 2. Users & Roles

UserDetailsService â†’ Spring Security ko user info provide karta hai

InMemoryUserDetailsManager â†’ memory-based user storage (DB ke bina)

Example user create:

User.withUsername("name")
    .password(encoder.encode("pass"))
    .roles("ROLE")
    .build();


âœ… 3. Password

PasswordEncoder compulsory (raw password allowed nahi)

Recommended â†’ BCryptPasswordEncoder (secure hashing)

âœ… 4. SecurityFilterChain

Important configs

csrf.disable() â†’ learning me theek, production me enable karna zaroori

authorizeHttpRequests() â†’ kis URL ko allow/deny karna hai

formLogin() fields

loginPage("/login") â†’ custom login page (GET request)

loginProcessingUrl("/doLogin") â†’ form POST submit yaha hoga (Spring handle karega)

defaultSuccessUrl("/success", true) â†’ login ke baad redirect (true â†’ hamesha /success par hi redirect)

failureUrl("/login?error=true") â†’ login fail par redirect

permitAll() â†’ login related pages sab access kar sakte hain

exceptionHandling()

accessDeniedPage("/unauthorized") â†’ agar role/authority match nahi karta to redirect

âœ… 5. Default Login Flow

User /login page open karega

Form POST karega â†’ /doLogin

Agar success â†’ /success

Agar fail â†’ /login?error=true

Agar unauthorized role â†’ /unauthorized

âœ… 6. Method-Level Security Annotations

@Secured

@Secured("ROLE_ADMIN")


Checks before method call

Simple aur fast role check

âš ï¸ ROLE_ prefix required

@PreAuthorize

@PreAuthorize("hasRole('ADMIN') or hasRole('MANAGER')")


Checks before method call

Supports SpEL (Spring Expression Language) â†’ complex conditions likh sakte ho

hasRole('ADMIN') internally = ROLE_ADMIN

@PostAuthorize

@PostAuthorize("returnObject.owner == authentication.name or hasRole('ADMIN')")


Checks after method execution

Useful jab return value authorize karni ho

Keywords:

returnObject = return value

authentication.name = logged-in username

âœ… 7. UsernamePasswordAuthenticationFilter

Ye filter login form submit hone ke baad POST request intercept karta hai

Default login processing URL â†’ /login (customizable via loginProcessingUrl())

Process:

Request se username aur password extract karta hai

Ek UsernamePasswordAuthenticationToken banata hai (credentials ka wrapper object)

Isko AuthenticationManager ko pass karta hai authentication ke liye

Agar sahi credentials â†’ SecurityContext me Authentication set ho jata hai

Agar galat credentials â†’ failure handler trigger hota hai (redirect/error message)

ğŸ‘‰ Matlab: Tumhe /doLogin endpoint banane ki zaroorat nahi hoti kyunki filter khud handle karta hai.

âœ… 8. AuthenticationManager

Ye core interface hai jo actual authentication karta hai

Input: Authentication object (usually UsernamePasswordAuthenticationToken)

Output:

Success â†’ fully authenticated Authentication object (with roles/authorities)

Fail â†’ Exception throw (BadCredentialsException, etc.)

Default kaam:

AuthenticationManager ek list of AuthenticationProviders maintain karta hai

Har provider try karta hai credentials verify karne ka (e.g., in-memory, DB, LDAP)

Jab ek provider successfully authenticate kar deta hai â†’ wo result return kar deta hai

âš¡ Default Implementation: ProviderManager

Typical flow:

UsernamePasswordAuthenticationFilter â†’ AuthenticationManager ko call karega

AuthenticationManager â†’ DaoAuthenticationProvider use karega

DaoAuthenticationProvider â†’ UserDetailsService call karega

UserDetailsService â†’ user fetch karega (in-memory/DB)

PasswordEncoder se password verify hoga

âœ… 9. Best Practices

Simple role check â†’ use @Secured

Complex multi-role / user-specific condition â†’ use @PreAuthorize

Return object based check â†’ use @PostAuthorize

Controller par â†’ API-level restriction

Service par â†’ business logic level restriction (more secure & reusable)

ğŸ‘‰ Bhai ab flow clear ho gaya:

Form Submit â†’ UsernamePasswordAuthenticationFilter

Auth Check â†’ AuthenticationManager â†’ AuthenticationProvider â†’ UserDetailsService + PasswordEncoder

Result â†’ Success (SecurityContext set) / Failure (error redirect)